{"version":3,"sources":["../index.js"],"names":["uncachedValue","getProxyData","createImmutable","immutableMethods","mutableMethods","cache","Proxy","get","target","propName","immutable","mutable","args","result","then","payload","undefined","module","exports","model","subscribers","dispatchQueue","isDispatching","buildStateProxy","readOnly","changes","disposed","onChange","prop","data","push","$$get","fromCache","loader","type","dispose","Error","getState","mapper","proxy","subscribe","subscriber","unsubcribed","lazyDispatch","queue","splice","item","innerDispatch","action","notify","state","unsubscribedIndexes","i","length","pop","actionResult","hasChange","dispatch","prevValue","nextValue","proxyData","propChanged","cached","prev","next","$$changes","$$dispose","setTimeout"],"mappings":"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","file":"index.js","sourcesContent":["const uncachedValue = {};\r\nconst getProxyData = \"@@ProxyData\";\r\n\r\nfunction createImmutable(\r\n  immutableMethods = {},\r\n  mutableMethods = {},\r\n  cache = {}\r\n) {\r\n  return new Proxy(cache, {\r\n    get(target, propName) {\r\n      if (propName === getProxyData) {\r\n        return {\r\n          immutable: immutableMethods,\r\n          mutable: mutableMethods,\r\n          cache\r\n        };\r\n      }\r\n\r\n      if (propName in immutableMethods || propName in mutableMethods) {\r\n        return function(...args) {\r\n          let result;\r\n          if (propName in immutableMethods) {\r\n            result = immutableMethods[propName](...args);\r\n            if (typeof result === \"function\") {\r\n              result = result(cache);\r\n            }\r\n            return result;\r\n          }\r\n\r\n          if (propName in mutableMethods) {\r\n            result = mutableMethods[propName](cache, ...args);\r\n\r\n            if (result && typeof result.then === \"function\") {\r\n              return result.then(payload => {\r\n                return createImmutable(immutableMethods, mutableMethods, cache);\r\n              });\r\n            }\r\n            return createImmutable(immutableMethods, mutableMethods, cache);\r\n          }\r\n          return undefined;\r\n        };\r\n      }\r\n\r\n      return undefined;\r\n    }\r\n  });\r\n}\r\n\r\nmodule.exports = function(model) {\r\n  const subscribers = [];\r\n  const dispatchQueue = [];\r\n  let isDispatching;\r\n\r\n  function buildStateProxy(readOnly) {\r\n    const cache = {};\r\n    const changes = {};\r\n    let disposed = false;\r\n\r\n    function onChange(prop, data) {\r\n      if (!changes[prop]) {\r\n        changes[prop] = [];\r\n      }\r\n      changes[prop].push(data);\r\n    }\r\n\r\n    function $$get(propName, fromCache) {\r\n      if (propName in cache) return cache[propName];\r\n\r\n      if (fromCache) {\r\n        return uncachedValue;\r\n      }\r\n\r\n      const loader = model[propName];\r\n\r\n      if (typeof loader !== \"function\") {\r\n        return loader;\r\n      }\r\n\r\n      return (cache[propName] = loader({\r\n        type: \"get\",\r\n        readOnly,\r\n        onChange(data) {\r\n          onChange(propName, data);\r\n        }\r\n      }));\r\n    }\r\n\r\n    function dispose() {\r\n      disposed = true;\r\n    }\r\n\r\n    return new Proxy(model, {\r\n      get(target, propName) {\r\n        if (propName === \"$$get\") return $$get;\r\n        if (propName === \"$$changes\") return changes;\r\n        if (propName === \"$$dispose\") return dispose;\r\n\r\n        if (!readOnly && disposed) {\r\n          // prvent user accesses to disposed state\r\n          // no limitation for readonly state\r\n          throw new Error(\"State is already disposed\");\r\n        }\r\n\r\n        return $$get(propName, false);\r\n      }\r\n    });\r\n  }\r\n\r\n  function getState(mapper) {\r\n    const proxy = buildStateProxy(true);\r\n\r\n    if (mapper) return mapper(proxy);\r\n\r\n    return proxy;\r\n  }\r\n\r\n  function subscribe(subscriber) {\r\n    subscribers.push(subscriber);\r\n    return function() {\r\n      subscriber.unsubcribed = true;\r\n    };\r\n  }\r\n\r\n  async function lazyDispatch() {\r\n    const queue = dispatchQueue.splice();\r\n    for (let item of queue) {\r\n      await innerDispatch(item.action, item.args);\r\n    }\r\n  }\r\n\r\n  function notify(state) {\r\n    const unsubscribedIndexes = [];\r\n\r\n    for (let i = 0; i < subscribers.length; i++) {\r\n      const subscriber = subscribers[i];\r\n      if (subscriber.unsubcribed) {\r\n        unsubscribedIndexes.push(i);\r\n        continue;\r\n      }\r\n      subscriber(state);\r\n    }\r\n    while (unsubscribedIndexes.length) {\r\n      subscribers.splice(unsubscribedIndexes.pop(), 1);\r\n    }\r\n  }\r\n\r\n  async function innerDispatch(action, args) {\r\n    isDispatching = true;\r\n    let state;\r\n\r\n    try {\r\n      let actionResult = await action(...args);\r\n      let hasChange = false;\r\n\r\n      if (typeof actionResult === \"function\") {\r\n        actionResult = await actionResult(\r\n          (state = buildStateProxy()),\r\n          dispatch\r\n        );\r\n      }\r\n\r\n      if (actionResult) {\r\n        if (!state) {\r\n          state = buildStateProxy();\r\n        }\r\n\r\n        for (let propName in actionResult) {\r\n          const prevValue = state.$$get(propName, true);\r\n          let nextValue = actionResult[propName];\r\n\r\n          if (nextValue) {\r\n            const proxyData = nextValue[getProxyData];\r\n            if (proxyData) {\r\n              nextValue = proxyData;\r\n            }\r\n          }\r\n\r\n          if (\r\n            prevValue !== nextValue &&\r\n            typeof model[propName] === \"function\"\r\n          ) {\r\n            if (prevValue !== uncachedValue && prevValue === nextValue) {\r\n              // nothing change\r\n            } else {\r\n              let propChanged = await model[propName]({\r\n                type: \"set\",\r\n                cached: prevValue !== uncachedValue,\r\n                get: () => state.$$get(propName),\r\n                prev: prevValue === uncachedValue ? undefined : prevValue,\r\n                next: nextValue\r\n              });\r\n\r\n              if (propChanged !== false) {\r\n                hasChange = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // detect change\r\n      const changes = state.$$changes;\r\n      for (let propName in changes) {\r\n        hasChange = true;\r\n\r\n        await model[propName]({\r\n          type: \"set\",\r\n          changes: changes[propName]\r\n        });\r\n      }\r\n\r\n      if (hasChange) {\r\n        notify(buildStateProxy(true));\r\n      }\r\n    } finally {\r\n      isDispatching = false;\r\n      if (state) {\r\n        state.$$dispose();\r\n      }\r\n    }\r\n\r\n    if (dispatchQueue.length) {\r\n      setTimeout(lazyDispatch);\r\n    }\r\n  }\r\n\r\n  function dispatch(action, ...args) {\r\n    if (isDispatching) {\r\n      dispatchQueue.push({ action, args });\r\n      return;\r\n    }\r\n    return innerDispatch(action, args);\r\n  }\r\n\r\n  return {\r\n    getState,\r\n    subscribe,\r\n    dispatch\r\n  };\r\n};\r\n\r\nmodule.exports.createImmutable = createImmutable;\r\n"]}